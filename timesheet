#!/usr/bin/env python3
# Scan a timesheet file for datetime entries of the type: [2017-03-13 11:45AM]
# Calculate the time between entries and use the first sentence of the first line as an identifier.
# Coalesce and total the hours from all identifiers which do not start with '-' and print them at the end.

# TODO: "Project" support based on ":" character?
# TODO: JIRA integration?
import os
import sys
import time
from datetime import datetime, timedelta

def roundTime(dt=None, roundTo=60):
	"""Round a datetime object to any time laps in seconds
	dt : datetime.datetime object, default now.
	roundTo : Closest number of seconds to round to, default 1 minute.
	Author: Thierry Husson 2012 - Use it as you want but don't blame me.
	"""
	if dt == None : dt = datetime.now()
	seconds = (dt - dt.min).seconds
	rounding = (seconds+roundTo/2) // roundTo * roundTo
	return dt + timedelta(0,rounding-seconds,-dt.microsecond)

def analyze(day_totals,timesheet_file, print_sheet=True, print_hours=True, entry_task=None, print_id_entry=True, print_id_hours=True):
	last_timestamp = None
	task_line = False
	task = ""
	entry = ""
	for line in timesheet_file:
		try:
			# *Not* ISO 8601 for the time portion, but I hate 24h time for readability
			timestamp = datetime.strptime(line, '[%Y-%m-%d %I:%M%p]\n')
			task_line = True
			
			if task == entry_task:
				if print_id_entry:
					print(entry,end='')
			entry = line
			
			if last_timestamp is not None:
				hours = (timestamp - last_timestamp).total_seconds()/60/60
				if print_hours:
					print("\t%.2fh" % hours)
				day_totals[task] += hours
			last_timestamp = timestamp
			if print_sheet:
				print(line,end='')
		except ValueError:
			entry += line
			if print_sheet:
				print(line,end='')
			if task_line:
				task = line.strip().split(".")[0]
				task_line = False
				if not task in day_totals:
					day_totals[task] = 0.0

def report_total(totals):
	total_hours = 0
	hours_print_width = 0
	first_entry = True
	for task, hours in sorted(totals.items(), key=lambda kv: (-kv[1], kv[0])):
		if task[:1] is not '-':
			# First valid entry, set the max print width (sorted, so it should be the longest)
			if first_entry:
				hours_print_width = len("%.2f" % hours)
				first_entry = False
			total_hours += hours
			print("%*.2fh: %s" % (hours_print_width, hours, task))

	print("\n%.2fh: Total" % total_hours)

def report(day_totals,timesheet_file):
	analyze(day_totals,timesheet_file)
	print("\n")
	report_total(day_totals)

def session_report(file_path, dates):
	session_totals = {}
	for file_date in dates:
		file_path = os.path.dirname(file_path) + "/" + file_date.strftime('%Y-%m-%d')
		if os.path.isfile(file_path):
			print(file_date.strftime('Report for %a %Y-%m-%d:'))
			day_totals = {}
			report(day_totals, open(file_path))
			for task, hours in day_totals.items():
				if task in session_totals:
					session_totals[task] += hours;
				else:
					session_totals[task] = hours;
			print('-' * 80)
	report_total(session_totals)

time_dir=os.path.expanduser(os.getenv('TIMESHEET_TIMEDIR', os.getcwd()))
today_timesheet_path = time.strftime(time_dir + "/%Y-%m-%d")

editor=os.getenv('TIMESHEET_EDITOR', 'vim')

interval=int(os.getenv('TIMESHEET_INTERVAL', '900'))

import argparse
parser = argparse.ArgumentParser(
	description='Generate reports for timesheet files. With no arguments, create new timesheet in $TIMESHEET_TIMEDIR for the current date with $TIMESHEET_EDITOR.',
	epilog='$TIMESHEET_TIMEDIR defaults for current directory when undefined. $TIMESHEET_EDITOR defaults to vim when undefined.')
parser.add_argument(
	"-r",
	help="Generate a time report for TIMESHEET. TIMESHEET defaults to current date in $TIMESHEET_TIMEDIR",
	nargs='?',
	metavar='TIMESHEET',
	type=argparse.FileType('r'),
	const=today_timesheet_path)
parser.add_argument(
	"-d",
	help="Generate reports for the last DAYS days, if they exist. Starts from TIMESHEET file if specified, uses current date if not. Defaults to 10 DAYS.",
	nargs='?',
	metavar='DAYS',
	type=int,
	const=10)
parser.add_argument(
	"-a",
	help="Generate reports for all time.",
	action="store_true")
parser.add_argument(
	"-s",
	help="Generate a current timestamp rounded to the nearest $TIMESHEET_INTERVAL. Defaults to 900 seconds (15 minutes).",
	action="store_true")
args = parser.parse_args()

if args.r is not None:
	file_path = os.path.realpath(args.r.name)
else:
	file_path = today_timesheet_path

if args.a:
	dates = list()
	for filename in sorted(os.listdir(os.path.dirname(file_path))):
		try:
			file_date = datetime.strptime(filename, '%Y-%m-%d')
			dates.append(file_date)
		except ValueError:
			pass
	session_report(file_path, dates)
elif args.d is not None:
	dates = list()
	file_date = datetime.strptime(os.path.basename(file_path), '%Y-%m-%d')
	file_date = file_date - timedelta(days=args.d-1)
	while args.d > 0:
		dates.append(file_date)
		file_date = file_date + timedelta(days=1)
		args.d -= 1
	session_report(file_path, dates)
elif args.r is not None:
	day_totals = {}
	report(day_totals, args.r)
elif args.s:
	print("[%s]" % (roundTime(roundTo=interval).strftime("%Y-%m-%d %I:%M%p")),end = '')
else:
	os.system(editor + " " + today_timesheet_path)
